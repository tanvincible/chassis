/* Chassis Vector Storage Engine - C API */
/* Version 0.1.0 */

/* Thread Safety: */
/* - chassis_open, chassis_free: Thread-safe if called with different indices */
/* - chassis_add, chassis_flush: Single-writer (exclusive access required) */
/* - chassis_search: Multi-reader (shared access allowed) */


#ifndef CHASSIS_H
#define CHASSIS_H

#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Opaque handle to a Chassis index (C-compatible)
 *
 * This is a zero-sized type that serves as an opaque handle for C.
 * C code only sees pointers to this type, never the actual struct.
 * The real data is stored in `ChassisIndexState`.
 */
typedef struct ChassisIndex {
  uint8_t _private[0];
} ChassisIndex;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Open or create a Chassis vector index
 *
 * # Arguments
 *
 * - `path`: UTF-8 encoded path to the index file (must not be NULL)
 * - `dimensions`: Number of dimensions per vector (must be > 0)
 *
 * # Returns
 *
 * - Non-NULL pointer on success
 * - NULL on failure (check `chassis_last_error_message()`)
 *
 * # Thread Safety
 *
 * - Safe to call from multiple threads with different paths
 * - The returned index requires exclusive access for writes
 *
 * # Example (C)
 *
 * ```c
 * ChassisIndex* index = chassis_open("vectors.chassis", 768);
 * if (index == NULL) {
 *     fprintf(stderr, "Error: %s\n", chassis_last_error_message());
 *     exit(1);
 * }
 * ```
 *
 * # Safety
 *
 * - `path` must be a valid, NULL-terminated UTF-8 string
 * - `path` must remain valid for the duration of this call
 * - Caller must free the returned pointer with `chassis_free()`
 */
struct ChassisIndex *chassis_open(const char *path, uint32_t dimensions);

/**
 * Open or create a Chassis vector index with custom options
 *
 * # Arguments
 *
 * - `path`: UTF-8 encoded path to the index file (must not be NULL)
 * - `dimensions`: Number of dimensions per vector (must be > 0)
 * - `max_connections`: Maximum connections per node (M parameter, typically 8-64)
 * - `ef_construction`: Construction quality (typically 100-400)
 * - `ef_search`: Search quality (typically 50-200)
 *
 * # Returns
 *
 * - Non-NULL pointer on success
 * - NULL on failure (check `chassis_last_error_message()`)
 *
 * # Parameter Guidelines
 *
 * - **max_connections (M)**: Higher = better recall, more memory. Default: 16
 * - **ef_construction**: Higher = better index quality, slower build. Default: 200
 * - **ef_search**: Higher = better search quality, slower search. Default: 50
 *
 * # Safety
 *
 * Same safety requirements as `chassis_open()`
 */
struct ChassisIndex *chassis_open_with_options(const char *path, uint32_t dimensions, uint32_t max_connections, uint32_t ef_construction, uint32_t ef_search);

/**
 * Free a Chassis index and release all resources
 *
 * # Arguments
 *
 * - `ptr`: Pointer returned by `chassis_open()` or NULL
 *
 * # Safety
 *
 * - `ptr` must be NULL or a valid pointer from `chassis_open()`
 * - After this call, `ptr` is invalid and must not be used
 * - Safe to call with NULL (no-op)
 * - Safe to call multiple times with the same pointer (undefined behavior
 *   on second call, but won't crash)
 *
 * # Example (C)
 *
 * ```c
 * chassis_free(index);
 * index = NULL; // Good practice
 * ```
 */
void chassis_free(struct ChassisIndex *ptr);

/**
 * Add a vector to the index
 *
 * # Arguments
 *
 * - `ptr`: Non-NULL pointer to index (requires exclusive access)
 * - `vector`: Pointer to f32 array (must not be NULL)
 * - `len`: Number of elements in vector (must match index dimensions)
 *
 * # Returns
 *
 * - Vector ID (0-based) on success
 * - `UINT64_MAX` on failure (check `chassis_last_error_message()`)
 *
 * # Thread Safety
 *
 * **SINGLE-WRITER**: Only one thread may call this function at a time for a
 * given index. Concurrent writes will cause data corruption.
 *
 * # Performance Note
 *
 * This operation does NOT guarantee durability. Call `chassis_flush()` to
 * ensure data is written to disk.
 *
 * # Example (C)
 *
 * ```c
 * float vec[768] = {0.1, 0.2, ...};
 * u64 id = chassis_add(index, vec, 768);
 * if (id == UINT64_MAX) {
 *     fprintf(stderr, "Add failed: %s\n", chassis_last_error_message());
 * }
 * ```
 *
 * # Safety
 *
 * - `ptr` must be non-NULL and valid
 * - `vector` must point to `len` valid f32 values
 * - `len` must match the dimensions specified in `chassis_open()`
 * - No other thread may access `ptr` during this call
 */
uint64_t chassis_add(struct ChassisIndex *ptr, const float *vector, size_t len);

/**
 * Search for k nearest neighbors
 *
 * # Arguments
 *
 * - `ptr`: Non-NULL pointer to index (shared access allowed)
 * - `query`: Pointer to query vector (must not be NULL)
 * - `len`: Number of elements in query (must match index dimensions)
 * - `k`: Number of neighbors to find (must be > 0)
 * - `out_ids`: Output buffer for vector IDs (must have space for k elements)
 * - `out_dists`: Output buffer for distances (must have space for k elements)
 *
 * # Returns
 *
 * - Number of results found (â‰¤ k) on success
 * - 0 on failure (check `chassis_last_error_message()`)
 *
 * # Thread Safety
 *
 * **MULTI-READER**: Multiple threads may call this function concurrently
 * on the same index. Reads do not block other reads.
 *
 * # Output Format
 *
 * Results are sorted by distance (ascending):
 * - `out_ids[0]` = closest vector ID
 * - `out_dists[0]` = distance to closest vector
 *
 * # Example (C)
 *
 * ```c
 * float query[768] = {0.1, 0.2, ...};
 * u64 ids[10];
 * float dists[10];
 *
 * size_t count = chassis_search(index, query, 768, 10, ids, dists);
 * for (size_t i = 0; i < count; i++) {
 *     printf("ID: %llu, Distance: %f\n", ids[i], dists[i]);
 * }
 * ```
 *
 * # Safety
 *
 * - `ptr` must be non-NULL and valid
 * - `query` must point to `len` valid f32 values
 * - `out_ids` must have space for at least `k` u64 values
 * - `out_dists` must have space for at least `k` float values
 * - Buffers must not overlap
 */
size_t chassis_search(const struct ChassisIndex *ptr, const float *query, size_t len, size_t k, uint64_t *out_ids, float *out_dists);

/**
 * Flush all changes to disk
 *
 * # Arguments
 *
 * - `ptr`: Non-NULL pointer to index (requires exclusive access)
 *
 * # Returns
 *
 * - 0 on success
 * - -1 on failure (check `chassis_last_error_message()`)
 *
 * # Thread Safety
 *
 * **SINGLE-WRITER**: Only one thread may call this function at a time for a
 * given index. No other operations (read or write) may occur during flush.
 *
 * # Performance Warning
 *
 * This operation is expensive (1-50ms depending on storage device).
 * Batch multiple `chassis_add()` calls and flush once at the end.
 *
 * # Example (C)
 *
 * ```c
 * // Add many vectors
 * for (int i = 0; i < 1000; i++) {
 *     chassis_add(index, vectors[i], 768);
 * }
 *
 * // Flush once at the end
 * if (chassis_flush(index) != 0) {
 *     fprintf(stderr, "Flush failed: %s\n", chassis_last_error_message());
 * }
 * ```
 *
 * # Safety
 *
 * - `ptr` must be non-NULL and valid
 * - No other thread may access `ptr` during this call
 */
int chassis_flush(struct ChassisIndex *ptr);

/**
 * Get the number of vectors in the index
 *
 * # Arguments
 *
 * - `ptr`: Non-NULL pointer to index (shared access)
 *
 * # Returns
 *
 * - Number of vectors, or 0 if `ptr` is NULL
 *
 * # Thread Safety
 *
 * Safe to call concurrently with `chassis_search()`.
 *
 * # Safety
 *
 * - `ptr` must be non-NULL and valid
 */
uint64_t chassis_len(const struct ChassisIndex *ptr);

/**
 * Check if the index is empty
 *
 * # Arguments
 *
 * - `ptr`: Non-NULL pointer to index (shared access)
 *
 * # Returns
 *
 * - 1 if empty, 0 if not empty or `ptr` is NULL
 *
 * # Safety
 *
 * - `ptr` must be non-NULL and valid
 */
int chassis_is_empty(const struct ChassisIndex *ptr);

/**
 * Get the dimensionality of vectors in the index
 *
 * # Arguments
 *
 * - `ptr`: Non-NULL pointer to index (shared access)
 *
 * # Returns
 *
 * - Number of dimensions, or 0 if `ptr` is NULL
 *
 * # Safety
 *
 * - `ptr` must be non-NULL and valid
 */
uint32_t chassis_dimensions(const struct ChassisIndex *ptr);

/**
 * Get the last error message for the current thread
 *
 * # Returns
 *
 * - Pointer to NULL-terminated error string
 * - NULL if no error occurred
 *
 * # Thread Safety
 *
 * Each thread has its own error message storage. Safe to call from multiple
 * threads concurrently.
 *
 * # Lifetime
 *
 * The returned pointer is valid until:
 * - The next FFI function call on this thread
 * - The thread exits
 *
 * **Do NOT** free the returned pointer.
 *
 * # Example (C)
 *
 * ```c
 * if (chassis_add(index, vec, 768) == UINT64_MAX) {
 *     const char* error = chassis_last_error_message();
 *     if (error != NULL) {
 *         fprintf(stderr, "Error: %s\n", error);
 *     }
 * }
 * ```
 */
const char *chassis_last_error_message(void);

/**
 * Get the Chassis library version
 *
 * # Returns
 *
 * Pointer to NULL-terminated version string (e.g., "0.1.0")
 *
 * # Lifetime
 *
 * The returned pointer is valid for the lifetime of the program.
 * **Do NOT** free the returned pointer.
 *
 * # Example (C)
 *
 * ```c
 * printf("Chassis version: %s\n", chassis_version());
 * ```
 */
const char *chassis_version(void);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* CHASSIS_H */
